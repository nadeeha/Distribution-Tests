import pandas as pd
import re

# Step 1: Load the CSV with all columns as strings
df = pd.read_csv("your_file.csv", dtype=str)

# Step 2: Define a function to detect and convert dates back to ranges
def fix_date_format(value):
    if isinstance(value, str):
        # Check if it looks like a date
        if re.match(r"^\d{1,2}-[A-Za-z]+$", value):
            # Example: convert '4-Mar' back to '3-4' or similar
            # Split the date-formatted string and retain only the day part
            day = re.match(r"^\d{1,2}", value).group(0)
            # Assuming that the month part represents the original range end, retrieve it
            end_range = str(int(day) + 1)  # Adjust end of range as needed
            return f"{day}-{end_range}"
    return value

# Step 3: Apply this function to the relevant column(s)
df['column_name'] = df['column_name'].apply(fix_date_format)

print(df['column_name'])  # Verify the column content






import pandas as pd
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import CountVectorizer
import seaborn as sns

# Load the data
iea_data = pd.read_csv("iea_clean_technology_guide.csv")
rbics_data = pd.read_csv("rbics_l6_categories.csv")

# Basic checks
print(iea_data.info())
print(rbics_data.info())

# Missing values
print("IEA missing values:\n", iea_data.isna().sum())
print("RBICS missing values:\n", rbics_data.isna().sum())

# Description length analysis
iea_data['description_length'] = iea_data['description'].apply(lambda x: len(str(x)))
rbics_data['description_length'] = rbics_data['description'].apply(lambda x: len(str(x)))

plt.figure(figsize=(10, 6))
sns.histplot(iea_data['description_length'], kde=True, label="IEA Description Length")
sns.histplot(rbics_data['description_length'], kde=True, color="orange", label="RBICS Description Length")
plt.legend()
plt.title("Description Length Distribution")
plt.show()

# Sector distribution in IEA data
plt.figure(figsize=(12, 6))
iea_data['sector'].value_counts().plot(kind='bar')
plt.title("Sector Distribution in IEA Data")
plt.show()

# Top keywords in descriptions using CountVectorizer
vectorizer = CountVectorizer(stop_words='english', max_features=10)
iea_keywords = vectorizer.fit_transform(iea_data['description'].fillna(""))
rbics_keywords = vectorizer.fit_transform(rbics_data['description'].fillna(""))

print("Top keywords in IEA Descriptions:", vectorizer.get_feature_names_out())
print("Top keywords in RBICS Descriptions:", vectorizer.get_feature_names_out())



import plotly.graph_objects as go

fig = go.Figure()
fig.add_trace(go.Histogram(x=iea_data['description_length'], name="IEA Descriptions"))
fig.add_trace(go.Histogram(x=rbics_data['description_length'], name="RBICS Descriptions"))
fig.update_layout(barmode='overlay', title="Description Length Distribution", xaxis_title="Description Length", yaxis_title="Count")
fig.update_traces(opacity=0.6)
fig.show()

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# Generate word cloud for IEA descriptions
text = " ".join(iea_data['description'].dropna().tolist())
wordcloud = WordCloud(width=800, height=400, background_color='white').generate(text)

# Plot Word Cloud
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.title("IEA Descriptions - Word Cloud")
plt.show()


import plotly.express as px

# Assuming df_iea is your DataFrame and theme is the column with 35 unique themes
# Replace `your_custom_color` with the color you want to use for the bars
custom_color = 'your_custom_color'  # Define your custom color here

fig = px.bar(df_iea['theme'].value_counts().reset_index(),
             x='index', y='theme',
             title="Theme Distribution in IEA Data",
             labels={'index': 'Theme', 'theme': 'Count'})

# Use custom color and improve readability
fig.update_traces(marker_color=custom_color)
fig.update_layout(xaxis={'categoryorder':'total descending'}, xaxis_tickangle=-45)
fig.show()


import streamlit as st
import plotly.express as px

# Load your preprocessed DataFrame
# df_iea = pd.read_csv("path/to/your/data.csv")  # Uncomment if loading from a CSV

# Dropdown for selecting a technology
selected_tech = st.selectbox("Select a Technology", df_iea['name'].unique())

# Filter data for the selected technology
filtered_data = df_iea[df_iea['name'] == selected_tech]

# Prepare data for plotting
trl_values = [filtered_data['trl2020'].values[0], filtered_data['trl2021'].values[0],
              filtered_data['trl2022'].values[0], filtered_data['trl2023'].values[0]]
years = ['2020', '2021', '2022', '2023']

# Plotting
fig = px.line(x=years, y=trl_values, title=f"TRL Over Time for {selected_tech}",
              labels={'x': 'Year', 'y': 'Technology Readiness Level'})

# Display the plot
st.plotly_chart(fig)





import pandas as pd

# Example data setup (replace with actual DataFrame)
# Assume df_iea has columns: 'name', 'trl2020', 'trl2021', 'trl2022', 'trl2023'

def convert_trl(value):
    if isinstance(value, str) and '-' in value:  # Check if it's a range
        start, end = map(float, value.split('-'))
        return (start + end) / 2
    else:
        return float(value)  # Convert single values to float directly

# Apply conversion to each TRL column
for col in ['trl2020', 'trl2021', 'trl2022', 'trl2023']:
    df_iea[col] = df_iea[col].apply(convert_trl)
