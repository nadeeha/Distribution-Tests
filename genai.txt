import openai

# Set OpenAI API Key
openai.api_key = "your-api-key"

def expand_level_3_circular_economy(level_1, level_2, level_3, keywords):
    """Expands Level 3 taxonomy under Circular Economy using keywords."""
    prompt = f"""
    You are an expert in sustainability and Circular Economy taxonomy. Expand and refine the Level 3 taxonomy under the given Level 1 and Level 2 categories within the Circular Economy theme. Use the provided keywords to generate related subcategories.

    - **Theme**: Circular Economy
    - **Level 1 Category**: {level_1}
    - **Level 2 Category**: {level_2}
    - **Existing Level 3 Category**: {level_3}
    - **Keywords**: {keywords}
    
    Provide a structured list of additional, well-defined Level 3 subcategories relevant to the Circular Economy. Return them in a **comma-separated format**.
    """

    response = openai.ChatCompletion.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=200
    )

    expanded_text = response["choices"][0]["message"]["content"].strip()
    return expanded_text


# Apply the Circular Economy expansion function to each row
df["expanded_level_3"] = df.apply(
    lambda row: expand_level_3_circular_economy(row["level_1"], row["level_2"], row["level_3"], row["keywords"]), axis=1
)

# Save the expanded taxonomy
df.to_csv("expanded_circular_economy_taxonomy.csv", index=False)

print("Circular Economy taxonomy expansion completed and saved.")



Here's a strong prompt you can use with the OpenAI API to filter the valid L6 level revenue streams that can be tagged under the circular economy:


---

Prompt:

> You are an expert in sustainability and circular economy principles. You will receive a list of 1800 revenue streams categorized under L6 level classification. Your task is to analyze each revenue stream and determine if it aligns with the principles of the circular economy.

A revenue stream is considered part of the circular economy if it contributes to any of the following:

Resource Efficiency & Waste Reduction: Minimizing material use, extending product life cycles, or reducing waste through reuse, repair, or recycling.

Recycling & Upcycling: Processing used materials into new products or repurposing materials to reduce waste.

Sustainable Materials & Renewable Resources: Using biodegradable, recyclable, or renewable materials.

Sharing Economy & Product-as-a-Service Models: Enabling resource sharing, rental, or subscription-based services to maximize product usage.

Industrial Symbiosis & Closed-Loop Systems: Utilizing byproducts or waste from one process as inputs for another.


Instructions:

Evaluate each L6 revenue stream based on the circular economy principles above.

If the revenue stream aligns with the circular economy, return it as valid. Otherwise, exclude it from the final list.

Return only the valid L6 revenue streams, without explanations or additional formatting.


Here is the list of L6 revenue streams:
[Insert the list of 1800 revenue streams here]




---

This prompt ensures that the OpenAI model filters only the relevant revenue streams aligned with the circular economy. If you want additional reasoning for each decision, you can modify the prompt to include a brief justification. Let me know if you need further refinements!





def keyword_search(rbics_clean, df_key):
    matches = []
    for keyword in df_key['keyword']:
        match_rows = rbics_clean[
            rbics_clean['L6_NAME'].str.contains(keyword, case=False, na=False) |
            rbics_clean['L6_DESCRIPTION'].str.contains(keyword, case=False, na=False)
        ]
        for _, row in match_rows.iterrows():
            matches.append({
                "L6_NAME": row['L6_NAME'],
                "L6_DESCRIPTION": row['L6_DESCRIPTION'],
                "matched_keyword": keyword
            })
    
    return pd.DataFrame(matches)

# Perform keyword search
exact_matches = keyword_search(rbics_clean, df_key)

import ace_tools as tools
tools.display_dataframe_to_user(name="Exact Keyword Match Results", dataframe=exact_matches)
